<!DOCTYPE html>

<head>
  <title>RanIDE Demo</title>
  <meta charset="UTF-8" />
  <script src="static/vue.js" type="text/javascript"></script>
  <script src="static/axios.js" type="text/javascript"></script>
  <link rel="shortcut icon" href="static/img/ran.ico" type="image/x-icon" />
  <link data-name="vs/editor/editor.main" rel="stylesheet" href="static/monaco-editor/min/vs/editor/editor.main.css">
  <script src="static/monaco-editor/min/vs/loader.js" type="text/javascript"></script>
  <script src="static/monaco-editor/min/vs/editor/editor.main.nls.js"></script>
  <script src="static/monaco-editor/min/vs/editor/editor.main.js"></script>
  <link
    rel="stylesheet"
    type="text/css"
    href="static/index.css"
  />
</head>
<body>
  <main>
    <div class="top">
      <button class="topbutton" id="run" type="button" @click="runCode">运行</button>
    </div>
    <div class="body">
      <div class="left"></div>
      <div class="main_ent">
	      <div id="wrapper"></div>
        <textarea id="terminal" spellcheck="false"></textarea>
      </div>
    </div>
  </main>
  <footer>
    RanIDE 2022
  </footer>
</body>

<script type="text/javascript">
    var login_page = new Vue({
    el: "main",
        data: {
			editor: null,
        },
        methods: {
            // 测试，获取文本内容
            // 测试，运行代码
            runCode(){
                const code = this.editor.getValue()
                axios({
                    method: 'POST',
                    url: 'http://127.0.0.1:5000/runCode',
                    data:{
                        code: code,
                    }
                })
            },
            //添加断点
            async addBreakPoint (line) {
              let model = this.editor.getModel()
              if (!model) return
              let value = {range: new monaco.Range(line, 1, line, 1), options: { isWholeLine: true, linesDecorationsClassName: 'breakpoints' }}
              model.deltaDecorations([], [value])
            },
            //删除断点，如果指定了line，删除指定行的断点，否则删除当前model里面的所有断点
            async removeBreakPoint (line) {
              let model = this.editor.getModel()
              if (!model) return
              let decorations
              let ids = []
              if (line !== undefined) {
                decorations = this.editor.getLineDecorations(line)
              } else {
                decorations = this.editor.getAllDecorations()
              }
              for (let decoration of decorations) {
                if (decoration.options.linesDecorationsClassName === 'breakpoints') {
                  ids.push(decoration.id)
                }
              }
              if (ids && ids.length) {
                model.deltaDecorations(ids, [])
              }
            },
            //判断该行是否存在断点
            hasBreakPoint (line) {
              let decorations = this.editor.getLineDecorations(line)
              for (let decoration of decorations) {
                if (decoration.options.linesDecorationsClassName === 'breakpoints') {
                  return true
                }
              }
              return false
            },
			isPythonEditor () {
				return this.editor.getModel().getLanguageId() === 'python'
			}
        },
        mounted: function() {
            require.config({ paths: { 'vs': 'static/monaco-editor/min/vs' } });
            require(['vs/editor/editor.main'], () => {
                monaco.editor.background = 'black';
                monaco.editor.foreground = 'black';
                monaco.editor.defineTheme('darkTheme', {
                    base: 'hc-black',
                    inherit: true,
                    rules: [{ background: '808080FF' }],
                    colors: {
                      'editors.foreground': '#f4f4f4',
                      'editorSuggestWidget.foreground': 'white',
                    }
                });
				monaco.editor.setTheme('darkTheme');
				let keywords = ["False","None","True","and","as","assert","async","await","break","class","continue",
					"def","del","elif","else","except","finally","for","from","global","if","import","in",
					"is","lambda","nonlocal","not","or","pass","raise","return","try","while","with","yield",
					"long","apply","basestring","buffer","cmp","coerce","execfile","file","intern","raw_input",
					"reduce","reload","self","unichr","unicode","xrange","__dict__","__methods__","__members__",
					"__class__","__bases__","__name__","__mro__","__subclasses__","__init__"];
				let builtins = ["abs","aiter","all","any","anext","ascii","bin","bool","breakpoint","bytearray","bytes",
					"callable","chr","classmethod","compile","complex","delattr","dict","dir","divmod","enumerate","eval",
					"exec","filter","float","format","frozenset","getattr","globals","hasattr","hash","help","hex","id",
					"input","int","isinstance","issubclass","iter","len","list","locals","map","max","memoryview","min","next",
					"object","oct","open","ord","pow","print","property","range","repr","reversed","round","set","setattr",
					"slice","sorted","staticmethod","str","sum","super","tuple","type","vars","zip","__import__"];
				monaco.languages.registerCompletionItemProvider('python', {
					provideCompletionItems: function () {
						let suggestions = [];
						keywords.forEach(item => {
							suggestions.push({
							label: item,
							kind: monaco.languages.CompletionItemKind.Keyword,
							insertText: item
							});
						})
						builtins.forEach(item => {
							suggestions.push({
							label: item,
							kind: monaco.languages.CompletionItemKind.Method,
							insertText: item
							});
						})
						return {   suggestions:suggestions    };
					},
				});
				// 默认文本
				var defaultCode = '';
				var model = monaco.editor.createModel(defaultCode, 'python');
				var editor = monaco.editor.create(document.getElementById('wrapper'), {
					value: "",
					language: 'python',
					wordBasedSuggestions: true,
					roundedSelection: false,
					scrollBeyondLastLine: false,
					readOnly: false,
					theme: 'darkTheme',
					model: model
				});

				this.editor = editor;
				this.editor.onDidChangeModelContent((event) => {
					let model = this.editor.getModel()
					// console.log('debug151')
					//必须在nextTick处理，不然getPosition返回的位置有问题
					this.$nextTick(() => {
						//获取当前的鼠标位置
						let pos = this.editor.getPosition()
						if (pos) {
							//获取当前的行
							let line = pos.lineNumber
							//如果当前行的内容为空，删除断点（空行不允许设置断点，我自己规定的，，，）
							if (this.editor.getModel().getLineContent(line).trim() === '') {
								// this.removeBreakPoint(line)
							} else {
								//如果当前行存在断点，删除多余的断点只保留一个
								if (this.hasBreakPoint(line)) {
									this.removeBreakPoint(line)
									this.addBreakPoint(line)
								}
							}
						}
					})
				})

				this.editor.onMouseDown((e) => {
					//我建立了很多不同种类的编辑器js, text等，这里只允许js编辑器添加breakpoint，如果你想在mousedown里面做点别的，放在这个前面啊，否则，return了，，，，
					if (!this.isPythonEditor()) return
					//这里限制了一下点击的位置，只有点击breakpoint应该出现的位置，才会创建，其他位置没反应
					if (e.target.detail && e.target.detail.offsetX && e.target.detail.offsetX >= 0 && e.target.detail.offsetX <= 10) {
					let line = e.target.position.lineNumber
					//空行不创建
					if (this.editor.getModel().getLineContent(line).trim() === '') {
						return
					}
					//如果点击的位置没有的话创建breakpoint，有的话，删除
					if (!this.hasBreakPoint(line)) {
						this.addBreakPoint(line)
					} else {
						this.removeBreakPoint(line)
					}
					//如果存在上个位置，将鼠标移到上个位置，否则使editor失去焦点
					if (this.lastPosition) {
						this.editor.setPosition(this.lastPosition)
					} else {
						document.activeElement.blur()
					}
					}
					//更新lastPosition为当前鼠标的位置（只有点击编辑器里面的内容的时候）
					if (e.target.type === 6 || e.target.type === 7) {
					this.lastPosition = this.editor.getPosition()
					}
				})
        	});
        }
    });

</script>