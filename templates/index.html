<!DOCTYPE html>

<head>
	<title>RanIDE Demo</title>
	<meta charset="UTF-8" />
	<script src="/static/vue.js" type="text/javascript"></script>
	<script src="/static/axios.js" type="text/javascript"></script>
	<link rel="shortcut icon" href="/static/img/ran.ico" type="image/x-icon" />
	<link data-name="vs/editor/editor.main" rel="stylesheet" href="/static/monaco-editor/min/vs/editor/editor.main.css">
	<script src="/static/monaco-editor/min/vs/loader.js" type="text/javascript"></script>
	<script src="/static/monaco-editor/min/vs/editor/editor.main.nls.js"></script>
	<script src="/static/monaco-editor/min/vs/editor/editor.main.js"></script>
	<link rel="stylesheet" type="text/css" href="/static/index.css" />
</head>

<body>
	<script>
		window.filename = "{{arg.filename}}";
	</script>
	<main>
		<div class="top">
			<button class="topbutton" id="save" type="button" @click="saveCode">保存</button>
			<button class="topbutton" id="run" type="button" @click="runCode">运行</button>
			<button class="topbutton" id="debug" type="button" @click="debugCode">调试</button>
			<button class="topbutton" id="kill" type="button" @click="killCode">终止</button>
			<button class="debugbutton" id="s" type="button" @click="debug_s">逐语句</button>
			<button class="debugbutton" id="n" type="button" @click="debug_n">逐过程</button>
			<button class="debugbutton" id="r" type="button" @click="debug_r">跳出函数</button>
			<button class="debugbutton" id="c" type="button" @click="debug_c">跳出</button>
		</div>
		<div class="body">
			<div class="left"></div>
			<div class="main_ent">
				<div id="wrapper"></div>
				<textarea id="terminal" spellcheck="false" @keydown.enter="inputTerminal" v-model="terminal"></textarea>
			</div>
		</div>
	</main>
	<footer>
		RanIDE 2022
	</footer>
</body>

<script type="text/javascript">
	var login_page = new Vue({
		el: "main",
		data: {
			editor: null,
			filename: null,
			terminal: "",
			timer: null,
			state: null,
			debug: null,
			line_number:null,
		},

		methods: {
			// 测试，终端显示
			inputTerminal(e){
				// 获取终端内容
				let terminal = this.terminal.split("\n");
				// 获取最后一行内容
				let input = terminal.pop();
				// 发送输入信息
				const path = "/input";
				let dataT = {
					filename: this.filename,
					input: input,
				};
				axios.post(path, dataT)
				.then((response) => {
					if(response.data === "done") {
						// alert("输入成功。");
					} else {
						alert("请检查网络。");
					}
				});
			},
			// 测试，定时器发送output的post请求
			myTimer(){
				this.timer = setInterval(() => {
					this.outputTerminal();
				}, 50);
			},
			// 测试，清除定时器
			clearTime(){
				clearInterval(this.timer);
			},
			// 测试，发送output的post请求
			outputTerminal(){
				// 发送输入信息
				const path = "/output";
				let dataT = {
					filename: this.filename,
					type: "output",
				};
				axios.post(path, dataT)
				.then((response) => {
                    let el_term = document.getElementById("terminal");
					if (response.data.value !== 0 && response.data.value !== -1) {
						let el_term = document.getElementById("terminal");
						el_term.value += response.data.value;
                        el_term.scrollTop = el_term.scrollHeight;
						this.highlight();
					}
					if(response.data.value === -1 && this.state === "running") {
						this.clearTime();
						this.state = "done";
						this.debug = "off";
						document.getElementById("terminal").value += "######### Done #########\n";
                        el_term.scrollTop = el_term.scrollHeight;
                        buttons = document.getElementsByClassName('debugbutton');
                        for (let i = 0; i < buttons.length; i++) {
                            buttons[i].style.display = 'none';
                        }
					}
				});
			},
			getCode() {
				const path = "/getCode";
				let dataT = {
					filename: this.filename,
				};
				axios.post(path, dataT)
				.then(
					(receive) => {
						this.editor.setValue(receive.data);
					}
				);
			},
			// 测试，获取文本内容
			// 测试，运行代码
			runCode() {
				let code = this.editor.getValue();
				const path = "/runCode";
				let dataT = {
					filename: this.filename,
					type: "python",
					code: this.editor.getValue()
				};
				axios.post(path, dataT)
				.then(
					(receive) => {
						if(receive.data === "done") {
							this.clearTime(); // 清除上次的计时器
							this.myTimer();
							this.state = "running";
							document.getElementById("terminal").value = ("####### Running #######\n");
						} else {
							alert("请检查网络，或等待进程运行结束。");
						}
					}
				);
			},
			async sendLoopPost(mylist) {
				for (let i = 0; i < mylist.length; i++) {
					let input = "b " + String(mylist[i] + 2);
					let dataT = {
						filename: this.filename,
						input: input,
					};
					await axios.post("/input", dataT)
					.then(
						(receive) => {
							console.log('@ ', i);
						}
					)
				}
			},
			highlight() {
				let offset = 0;
				if (this.debug === "on") {
					offset = 2;
				}
				let terminal = document.getElementById("terminal").value;
				//console.log(terminal);
				let reg_match = />.*\\(\S+)\((\d+)\)<module>/gm;
				rows = terminal.match(reg_match);
				//console.log(rows)
				file = RegExp.$1;
				num = RegExp.$2;
				//console.log(file);
				//console.log(num);
				// file留到之后文件切换使用
                num = Number(num) - offset
				if (file !== this.filename) return
				if (this.line_number === null) {
					lines = document.getElementsByClassName('line-numbers')
					line = lines[num - 1]
					line.className = 'active-line-number line-numbers'
				}
				else if (this.line_number !== num) {
                    lines = document.getElementsByClassName('line-numbers')
					line = lines[num - 1]
					oldline = lines[this.line_number-1]
					line.className = 'active-line-number line-numbers'
					oldline.className = 'line-numbers'
				}
				//console.log(this.line_number)
				this.line_number = num

			},
			debugCode(){
				let code = this.editor.getValue();
				const path = "/debugCode";
				// 读取断点位置
				let breakpoints = [];
				let model = this.editor.getModel();
				let linenum = model.getLineCount();
				for(let line = 1; line <= linenum; line++){
					if(this.hasBreakPoint(line)){
						breakpoints.push(line);
					}
				}
				let dataT = {
					filename: this.filename,
					type: "python",
					code: code,
					breakpoints: breakpoints.join(",")
				};
				axios.post(path, dataT)
				.then(
					(receive) => {
						if (receive.data === "done") {
							this.myTimer();
							this.state = "running";
							this.debug = "on"
                            document.getElementById("terminal").value = ("####### debugging #######\n");
							alert("调试请求发送成功");
							buttons = document.getElementsByClassName('debugbutton');
							for (let i = 0; i < buttons.length; i++) {
								buttons[i].style.display = 'inline-block';
							}
							this.sendLoopPost(breakpoints);
						}
					}
				)
			},
			killCode() {
				if(this.state != "running") {
					alert('程序未运行。');
					return;
				}
				const path = "/killCode";
				let dataT = {
					filename: this.filename,
				};
				axios.post(path, dataT)
				.then(
					(receive) => {
						if(receive.data === "done") {
							this.clearTime();
							this.state = 'done';
							alert("已终止。");
                            buttons = document.getElementsByClassName('debugbutton')
                            for (let i = 0; i < buttons.length; i++) {
                                buttons[i].style.display = 'none'
                            }
						}
					}
				);
			},
			saveCode() {
				let code = this.editor.getValue();
				const path = "/saveCode";
				let dataT = {
					filename: this.filename,
					code: code,
				};
				axios.post(path, dataT)
				.then(
					(receive) => {
						if(receive.data === "done") {
							//alert("保存成功。");
						} else {
							alert("请检查网络。");
						}
					}
				);
			},
			debug_s() {
                let code = this.editor.getValue();
				const path = "/input";
				input = 's'
                let dataT = {
                    filename: this.filename,
                    input: input,
                };
                axios.post(path, dataT)
                    .then((response) => {
                        if (response.data === "done") {
                             //alert("单步成功。");
                        } else {
                            alert("请检查网络。");
						}
                    });
			},
            debug_n() {
                let code = this.editor.getValue();
                const path = "/input";
                input = 'n'
                let dataT = {
                    filename: this.filename,
                    input: input,
                };
                axios.post(path, dataT)
                    .then((response) => {
                        if (response.data === "done") {
                            //alert("单步成功。");
                        } else {
                            alert("请检查网络。");
                        }
                    });
			},
            debug_r() {
                let code = this.editor.getValue();
                const path = "/input";
                input = 'r'
                let dataT = {
                    filename: this.filename,
                    input: input,
                };
                axios.post(path, dataT)
                    .then((response) => {
                        if (response.data === "done") {
                            //alert("单步成功。");
                        } else {
                            alert("请检查网络。");
                        }
                    });
			},
            debug_c() {
                let code = this.editor.getValue();
                const path = "/input";
                input = 'c'
                let dataT = {
                    filename: this.filename,
                    input: input,
                };
                axios.post(path, dataT)
                    .then((response) => {
                        if (response.data === "done") {
                            //alert("单步成功。");
                        } else {
                            alert("请检查网络。");
                        }
                    });
            },
			//添加断点
			async addBreakPoint(line) {
				let model = this.editor.getModel()
				if (!model) return
				let value = { range: new monaco.Range(line, 1, line, 1), options: { isWholeLine: true, linesDecorationsClassName: "breakpoints" } }
				model.deltaDecorations([], [value])
				if (this.debug === 'on') {
					let input = "b " + String(line + 2);  //之后多文件可能还得改file
					console.log(input)
					let dataT = {
						filename: this.filename,
						input: input,
					};
					await axios.post("/input", dataT)
						.then(
							(receive) => {
							}
						)
				}
			},
			//删除断点，如果指定了line，删除指定行的断点，否则删除当前model里面的所有断点
			async removeBreakPoint(line) {
				let model = this.editor.getModel()
				if (!model) return
				let decorations
				let ids = []
				if (line !== undefined) {
					decorations = this.editor.getLineDecorations(line)
				} else {
					decorations = this.editor.getAllDecorations()
				}
				for (let decoration of decorations) {
					if (decoration.options.linesDecorationsClassName === "breakpoints") {
						ids.push(decoration.id)
					}
				}
				if (ids && ids.length) {
					model.deltaDecorations(ids, [])
				}
                if (this.debug === 'on') {
					let input = "cl " + 'debug\\' + String(this.filename) + ':' + String(line + 2);  //之后多文件可能还得改file
                    console.log(input)
                    let dataT = {
                        filename: this.filename,
                        input: input,
                    };
                    await axios.post("/input", dataT)
                        .then(
                            (receive) => {
                            }
                        )
                }
			},
			//判断该行是否存在断点
			hasBreakPoint(line) {
				let decorations = this.editor.getLineDecorations(line)
				for (let decoration of decorations) {
					if (decoration.options.linesDecorationsClassName === "breakpoints") {
						return true
					}
				}
				return false
			},
			//添加一个伪breakpoint
			addFakeBreakPoint(line) {
				let model = this.editor.getModel()
				if (!model) return
				let value = { range: new monaco.Range(line, 1, line, 1), options: { isWholeLine: true, linesDecorationsClassName: "breakpoints-fake" } }
				model.deltaDecorations([], [value])		
			},
			//删除所有的伪breakpoint
			removeFakeBreakPoint() {
				let model = this.editor.getModel()
				if (!model) return
				let decorations
				let ids = []
				linenum=model.getLineCount()
				decorations = model.getAllDecorations()
				for (let decoration of decorations) {
					if (decoration.options.linesDecorationsClassName === "breakpoints-fake") {
						ids.push(decoration.id)
					}
				}
				if (ids && ids.length) {
					model.deltaDecorations(ids, [])
				}
			},
			isPythonEditor() {
				return this.editor.getModel().getLanguageId() === "python"
			},
			insertContent(text) {
				if (this.editor) {
					let selection = this.editor.getSelection()
					let range = new monaco.Range(selection.startLineNumber, selection.startColumn, selection.endLineNumber, selection.endColumn)
					let id = { major: 1, minor: 1 }
					let op = { identifier: id, range: range, text: text, forceMoveMarkers: true }
					this.editor.executeEdits(this.root, [op])
					this.editor.focus()
				}
			},
			trigger(id) {
				if (!this.editor) return
				this.editor.trigger("anyString", id)
			},
			//这个函数是从网上找的，用于自定义一个TextModelService，替换原先的
			getTextModelService() {
				return {
					createModelReference(uri) {
						const model = {
							load() {
								return Promise.resolve(model)
							},
							dispose() {
							},
							textEditorModel: monaco.editor.getModel(uri)
						}
						return Promise.resolve({
							object: model,
							dispose() {
							}
						})
					}
				}
			},
			//这个两个方法是为了替换CodeEditorService，可以看出和上面的实现不一样，区别在哪里呢
			//本来也是打算按照上面的方法来做的，但是也看到了上面的方法需要定义各种需要用到的方法，你得很理解这个Service才可以自己定义啊
			//这个就不需要了，只通过原型修改了两个相关的方法，然后其他的就不需要关心了
			//上面的好处是在创建editor的时候使用上面的service代替，只影响替换了的editor，下面这个直接影响了所有的editor
			//具体使用什么方法可以自己考量，我这个service采用了这种方法，主要是因为自定义的service各种报错，失败了，，，
			initGoToDefinitionCrossModels() {
				let self = this
				StandaloneCodeEditorServiceImpl.prototype.findModel = function (editor, resource) {
					let model = null
					if (resource !== null) {
						model = monaco.editor.getModel(resource)
					}
					return model
				}

				StandaloneCodeEditorServiceImpl.prototype.doOpenEditor = function (editor, input) {
					//这个this.findModel调用的是StandaloneCodeEditorServiceImpl.prototype.findModel这个方法
					let model = this.findModel(editor, input.resource)
					if (model) {
						editor.setModel(model)
					} else {
						return null
					}
					let selection = input.options.selection
					if (selection) {
						if (typeof selection.endLineNumber === "number" && typeof selection.endColumn === "number")
							editor.setSelection(selection)
						editor.revealRangeInCenter(selection, 1 /* Immediate */)
					} else {
						let pos = {
							lineNumber: selection.startLineNumber,
							column: selection.startColumn
						}
						editor.setPosition(pos)
						editor.revealPositionInCenter(pos, 1 /* Immediate */)
					}
					editor.focus()
				}
				return editor
			}


		},
		mounted: function () {
		
			// get filename from 
			this.filename = window.filename;
			// this.code = this.getCode();

			require.config({ paths: { "vs": "/static/monaco-editor/min/vs" } });
			require(["vs/editor/editor.main"], () => {
				monaco.editor.background = "black";
				monaco.editor.foreground = "black";
				monaco.editor.defineTheme("darkTheme", {
					base: "hc-black",
					inherit: true,
					rules: [{ background: "808080FF" }],
					colors: {
						"editors.foreground": "#f4f4f4",
						"editorSuggestWidget.foreground": "white",
					}
				});
				monaco.editor.setTheme("darkTheme");
				let keywords = ["False","None","True","and","as","assert","async","await","break","class","continue",
					"def","del","elif","else","except","finally","for","from","global","if","import","in",
					"is","lambda","nonlocal","not","or","pass","raise","return","try","while","with","yield",
					"long","apply","basestring","buffer","cmp","coerce","execfile","file","intern","raw_input",
					"reduce","reload","self","unichr","unicode","xrange","__dict__","__methods__","__members__",
					"__class__","__bases__","__name__","__mro__","__subclasses__","__init__"];
				let builtins = ["abs","aiter","all","any","anext","ascii","bin","bool","breakpoint","bytearray","bytes",
					"callable","chr","classmethod","compile","complex","delattr","dict","dir","divmod","enumerate","eval",
					"exec","filter","float","format","frozenset","getattr","globals","hasattr","hash","help","hex","id",
					"input","int","isinstance","issubclass","iter","len","list","locals","map","max","memoryview","min","next",
					"object","oct","open","ord","pow","print","property","range","repr","reversed","round","set","setattr",
					"slice","sorted","staticmethod","str","sum","super","tuple","type","vars","zip","__import__"];
				// 多行正则匹配
				let reg_match = /^\s*([a-z,A-Z,_][a-z,A-Z,0-9,_]*[.])*([a-z,A-Z,_][a-z,A-Z,0-9,_]*)\s*=/gm;
				let exp_match = /([a-z,A-Z,_][a-z,A-Z,0-9,_]*)\s*[:][=].*/gm;
				let for_match = /^\s*for\s*([a-z,A-Z,_][a-z,A-Z,0-9,_]*)\s*in/gm;
				let as_match = /\s*as\s*([a-z,A-Z,_][a-z,A-Z,0-9,_]*)/gm;
				let fun_match = /^\s*def\s*([a-z,A-Z,_][a-z,A-Z,0-9,_]*)\s*[(].*[)][:]/gm;
				monaco.languages.registerCompletionItemProvider("python", {
					provideCompletionItems: function () {
						let text = editor.getValue();
						let variables = [];
						while (matches = reg_match.exec(text)) {
							variables.push(matches[2]);
						}
						while (matches = exp_match.exec(text)) {
							variables.push(matches[1]);
						}
						while (matches = for_match.exec(text)) {
							variables.push(matches[1]);
						}
						while (matches = as_match.exec(text)) {
							variables.push(matches[1]);
						}
						variables = [...new Set(variables)];
						let functions = [];
						while (matches = fun_match.exec(text)) {
							functions.push(matches[1]);
						}
						functions = [...new Set(functions)];
						let suggestions = [];
						keywords.forEach(item => {
							suggestions.push({
								label: item,
								kind: monaco.languages.CompletionItemKind.Keyword,
								insertText: item
							});
						});
						builtins.forEach(item => {
							suggestions.push({
								label: item+' (builtin)',
								kind: monaco.languages.CompletionItemKind.Method,
								insertText: item
							});
						});
						variables.forEach(item => {
							if(!(keywords.includes(item)) && !(builtins.includes(item))) {
								suggestions.push({
									label: item,
									kind: monaco.languages.CompletionItemKind.Variable,
									insertText: item
								});
							}
						});
						functions.forEach(item => {
							if(!(keywords.includes(item)) && !(builtins.includes(item))) {
								suggestions.push({
									label: item+' (function)',
									kind: monaco.languages.CompletionItemKind.Method,
									insertText: item
								});
							}
						});
						return {
							suggestions:suggestions
						};
					},
				});
				// 默认文本
				var defaultCode = "";
				var model = monaco.editor.createModel(defaultCode, "python");
				var editor = monaco.editor.create(document.getElementById("wrapper"), {
					value: "",
					language: "python",
					automaticLayout: true,
					wordBasedSuggestions: true,
					roundedSelection: false,
					scrollBeyondLastLine: false,
					readOnly: false,
					theme: "darkTheme",
					model: model
				});

				this.editor = editor;
				this.editor.onDidChangeModelContent((event) => {
					let model = this.editor.getModel();
					// console.log("debug151")
					//必须在nextTick处理，不然getPosition返回的位置有问题
					this.$nextTick(() => {
						//获取当前的鼠标位置
						let pos = this.editor.getPosition();
						if (pos) {
							//获取当前的行
							let line = pos.lineNumber;
							//如果当前行的内容为空，删除断点（空行不允许设置断点）
							if (this.editor.getModel().getLineContent(line).trim() === "") {
								// this.removeBreakPoint(line)
							} else {
								//如果当前行存在断点，删除多余的断点只保留一个
								if (this.hasBreakPoint(line)) {
									this.removeBreakPoint(line);
									this.addBreakPoint(line);
								}
							}
						}
					});
				})
				this.editor.onMouseDown((e) => {
					//这里只允许python编辑器添加breakpoint，如果你想在mousedown里面做点别的
					if (!this.isPythonEditor()) return;
					//这里限制了一下点击的位置，只有点击breakpoint应该出现的位置，才会创建，其他位置没反应
					if (e.target.detail && e.target.detail.offsetX && e.target.detail.offsetX >= 0 && e.target.detail.offsetX <= 10) {
						let line = e.target.position.lineNumber;
						//空行不创建
						if (this.editor.getModel().getLineContent(line).trim() === "") {
							return;
						}
						//如果点击的位置没有的话创建breakpoint，有的话，删除
						if (!this.hasBreakPoint(line)) {
							//console.log(this)
							this.addBreakPoint(line);
						} else {
							this.removeBreakPoint(line);
						}
						//如果存在上个位置，将鼠标移到上个位置，否则使editor失去焦点
						if (this.lastPosition) {
							this.editor.setPosition(this.lastPosition);
						} else {
							document.activeElement.blur();
						}
					}
					//更新lastPosition为当前鼠标的位置（只有点击编辑器里面的内容的时候）
					if (e.target.type === 6 || e.target.type === 7) {
						this.lastPosition = this.editor.getPosition();
					}
				});
				//调用initGoToDefinitionCrossModels方法
				//this.editor.multiplemodelsearch( (e) => {this.initGoToDefinitionCrossModels()} )
				this.editor.initGoToDefinitionCrossModels;

				this.editor.onMouseMove((e) => {
					if (!this.isPythonEditor()) return;
					this.removeFakeBreakPoint();
					if(e.target.position === null) return; // 避免鼠标悬停在自动补全待选项上报错
					let line = e.target.position.lineNumber;
					if (this.hasBreakPoint(line)) return;
					//this.removeFakeBreakPoint()
					if (e.target.detail && e.target.detail.offsetX && e.target.detail.offsetX >= 0 && e.target.detail.offsetX <= 10) {
						let line = e.target.position.lineNumber;
						//console.log("行数为：",line)
						this.addFakeBreakPoint(line);
					}
				});
				this.editor.onMouseLeave(() => {
					this.removeFakeBreakPoint()
				})
				//这个是因为鼠标放在breakpoint的位置，然后焦点在editor里面，点击enter的话，出现好多伪breakpoint，emmmm，我也不知道怎么回事，没办法，按enter键的话，强制删除所有的伪breakpoint
				this.editor.onKeyDown((e) => {
					if (e.code === "Enter") {
						this.removeFakeBreakPoint();
					}
				});
				this.getCode();
			});
		}
	});

</script>